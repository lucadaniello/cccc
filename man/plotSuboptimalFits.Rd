% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotSuboptimalFits.R
\name{plotSuboptimalFits}
\alias{plotSuboptimalFits}
\title{Plot Suboptimal Smoothed Curves for Selected Keywords}
\usage{
plotSuboptimalFits(
  data,
  opt_res,
  n_curves = 9,
  show_zone = FALSE,
  graph = FALSE
)
}
\arguments{
\item{data}{A list containing the outputs returned by \code{\link[=importData]{importData()}}}

\item{opt_res}{A list with the optimal smoothing configuration returned by \code{\link[=optimalSmoothing]{optimalSmoothing()}}:}

\item{n_curves}{Integer. Number of keywords to display, chosen across the RMS distribution (default is 9).}

\item{show_zone}{Logical. If \code{TRUE}, include the frequency zone (if available in \code{tdm}) in the plot labels.}

\item{graph}{Logical. If \code{TRUE}, print all individual and combined plots to the active device (default is \code{FALSE}).}
}
\value{
A named list with the following elements (returned invisibly):
\itemize{
\item \code{singleKeywordPlot}: A list of ggplot objects, one for each selected keyword (full title included).
\item \code{combinedKeywordPlot}: A combined \code{patchwork} plot showing all selected fits.
}
}
\description{
This function visualizes raw and smoothed time trends of keyword frequencies based on smoothing spline fits.
A subset of keywords is selected based on the residual Root Mean Square (RMS) error of the smoothed fit.
Both individual and combined plots are returned.
}
\details{
The function first extracts the smoothed spline fit based on the optimal parameters.
It then computes the residual RMS for each keyword and selects a subset using quantiles.
Each keyword's frequency curve (raw and smoothed) is plotted, either individually or in a combined layout using the \code{patchwork} package.
}
\examples{
\dontrun{
tdm <- system.file("extdata", "tdm.csv", package = "cccc")
corpus <- system.file("extdata", "corpus.csv", package = "cccc")
data <- importData(tdm_file = tdm, corpus_file = corpus,
sep_tdm = ";",sep_corpus_info = ";",zone="stat")

data_nchi <- normalization(data, normty = "nchi", sc = 1000)

res_list <- list(
  "m-2" = smoothingSelection(data_nchi, penalty_type = "m-2", plot = FALSE),
  "2"   = smoothingSelection(data_nchi, penalty_type = "2", plot = FALSE),
  "1"   = smoothingSelection(data_nchi, penalty_type = "1", plot = FALSE),
  "0"   = smoothingSelection(data_nchi, penalty_type = "0", plot = FALSE)
)

opt <- optimalSmoothing(res_list)

  result <- plotSuboptimalFits(data = data_nchi, opt_res = opt, graph = TRUE)
}

}
